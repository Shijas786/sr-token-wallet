{"ast":null,"code":"import _asyncToGenerator from \"/Users/shijas/works/sr-token-wallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n  #provider;\n  #filterIdPromise;\n  #poller;\n  #running;\n  #network;\n  #hault;\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#filterIdPromise = null;\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#network = null;\n    this.#hault = false;\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  #poll(blockNumber) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        // Subscribe if necessary\n        if (_this.#filterIdPromise == null) {\n          _this.#filterIdPromise = _this._subscribe(_this.#provider);\n        }\n        // Get the Filter ID\n        let filterId = null;\n        try {\n          filterId = yield _this.#filterIdPromise;\n        } catch (error) {\n          if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n            throw error;\n          }\n        }\n        // The backend does not support Filter ID; downgrade to\n        // polling\n        if (filterId == null) {\n          _this.#filterIdPromise = null;\n          _this.#provider._recoverSubscriber(_this, _this._recover(_this.#provider));\n          return;\n        }\n        const network = yield _this.#provider.getNetwork();\n        if (!_this.#network) {\n          _this.#network = network;\n        }\n        if (_this.#network.chainId !== network.chainId) {\n          throw new Error(\"chaid changed\");\n        }\n        if (_this.#hault) {\n          return;\n        }\n        const result = yield _this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n        yield _this._emitResults(_this.#provider, result);\n      } catch (error) {\n        console.log(\"@TODO\", error);\n      }\n      _this.#provider.once(\"block\", _this.#poller);\n    })();\n  }\n  #teardown() {\n    const filterIdPromise = this.#filterIdPromise;\n    if (filterIdPromise) {\n      this.#filterIdPromise = null;\n      filterIdPromise.then(filterId => {\n        if (this.#provider.destroyed) {\n          return;\n        }\n        this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n      });\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#hault = true;\n    this.#teardown();\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#teardown();\n    }\n    this.#provider.off(\"block\", this.#poller);\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  #event;\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    this.#event = copy(filter);\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, this.#event);\n  }\n  _subscribe(provider) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const filterId = yield provider.send(\"eth_newFilter\", [_this2.#event]);\n      return filterId;\n    })();\n  }\n  _emitResults(provider, results) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      for (const result of results) {\n        provider.emit(_this3.#event, provider._wrapLog(result, provider._network));\n      }\n    })();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  _subscribe(provider) {\n    return _asyncToGenerator(function* () {\n      return yield provider.send(\"eth_newPendingTransactionFilter\", []);\n    })();\n  }\n  _emitResults(provider, results) {\n    return _asyncToGenerator(function* () {\n      for (const result of results) {\n        provider.emit(\"pending\", result);\n      }\n    })();\n  }\n}\n//# sourceMappingURL=subscriber-filterid.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}