{"ast":null,"code":"import _asyncToGenerator from \"/Users/shijas/works/sr-token-wallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */\nimport { resolveAddress } from \"../address/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\nimport { copyRequest } from \"./provider.js\";\nfunction checkProvider(signer, operation) {\n  if (signer.provider) {\n    return signer.provider;\n  }\n  assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n    operation\n  });\n}\nfunction populate(_x, _x2) {\n  return _populate.apply(this, arguments);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */\nfunction _populate() {\n  _populate = _asyncToGenerator(function* (signer, tx) {\n    let pop = copyRequest(tx);\n    if (pop.to != null) {\n      pop.to = resolveAddress(pop.to, signer);\n    }\n    if (pop.from != null) {\n      const from = pop.from;\n      pop.from = Promise.all([signer.getAddress(), resolveAddress(from, signer)]).then(([address, from]) => {\n        assertArgument(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n        return address;\n      });\n    } else {\n      pop.from = signer.getAddress();\n    }\n    return yield resolveProperties(pop);\n  });\n  return _populate.apply(this, arguments);\n}\nexport class AbstractSigner {\n  /**\n   *  The provider this signer is connected to.\n   */\n  provider;\n  /**\n   *  Creates a new Signer connected to %%provider%%.\n   */\n  constructor(provider) {\n    defineProperties(this, {\n      provider: provider || null\n    });\n  }\n  getNonce(blockTag) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return checkProvider(_this, \"getTransactionCount\").getTransactionCount(yield _this.getAddress(), blockTag);\n    })();\n  }\n  populateCall(tx) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const pop = yield populate(_this2, tx);\n      return pop;\n    })();\n  }\n  populateTransaction(tx) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const provider = checkProvider(_this3, \"populateTransaction\");\n      const pop = yield populate(_this3, tx);\n      if (pop.nonce == null) {\n        pop.nonce = yield _this3.getNonce(\"pending\");\n      }\n      if (pop.gasLimit == null) {\n        pop.gasLimit = yield _this3.estimateGas(pop);\n      }\n      // Populate the chain ID\n      const network = yield _this3.provider.getNetwork();\n      if (pop.chainId != null) {\n        const chainId = getBigInt(pop.chainId);\n        assertArgument(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n      } else {\n        pop.chainId = network.chainId;\n      }\n      // Do not allow mixing pre-eip-1559 and eip-1559 properties\n      const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n      if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n        assertArgument(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n      } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n        assertArgument(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n      }\n      if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n        // Fully-formed EIP-1559 transaction (skip getFeeData)\n        pop.type = 2;\n      } else if (pop.type === 0 || pop.type === 1) {\n        // Explicit Legacy or EIP-2930 transaction\n        // We need to get fee data to determine things\n        const feeData = yield provider.getFeeData();\n        assert(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"getGasPrice\"\n        });\n        // Populate missing gasPrice\n        if (pop.gasPrice == null) {\n          pop.gasPrice = feeData.gasPrice;\n        }\n      } else {\n        // We need to get fee data to determine things\n        const feeData = yield provider.getFeeData();\n        if (pop.type == null) {\n          // We need to auto-detect the intended type of this transaction...\n          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n            // The network supports EIP-1559!\n            // Upgrade transaction from null to eip-1559\n            if (pop.authorizationList && pop.authorizationList.length) {\n              pop.type = 4;\n            } else {\n              pop.type = 2;\n            }\n            if (pop.gasPrice != null) {\n              // Using legacy gasPrice property on an eip-1559 network,\n              // so use gasPrice as both fee properties\n              const gasPrice = pop.gasPrice;\n              delete pop.gasPrice;\n              pop.maxFeePerGas = gasPrice;\n              pop.maxPriorityFeePerGas = gasPrice;\n            } else {\n              // Populate missing fee data\n              if (pop.maxFeePerGas == null) {\n                pop.maxFeePerGas = feeData.maxFeePerGas;\n              }\n              if (pop.maxPriorityFeePerGas == null) {\n                pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n              }\n            }\n          } else if (feeData.gasPrice != null) {\n            // Network doesn't support EIP-1559...\n            // ...but they are trying to use EIP-1559 properties\n            assert(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"populateTransaction\"\n            });\n            // Populate missing fee data\n            if (pop.gasPrice == null) {\n              pop.gasPrice = feeData.gasPrice;\n            }\n            // Explicitly set untyped transaction to legacy\n            // @TODO: Maybe this shold allow type 1?\n            pop.type = 0;\n          } else {\n            // getFeeData has failed us.\n            assert(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"signer.getFeeData\"\n            });\n          }\n        } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {\n          // Explicitly using EIP-1559 or EIP-4844\n          // Populate missing fee data\n          if (pop.maxFeePerGas == null) {\n            pop.maxFeePerGas = feeData.maxFeePerGas;\n          }\n          if (pop.maxPriorityFeePerGas == null) {\n            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n          }\n        }\n      }\n      //@TOOD: Don't await all over the place; save them up for\n      // the end for better batching\n      return yield resolveProperties(pop);\n    })();\n  }\n  populateAuthorization(_auth) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const auth = Object.assign({}, _auth);\n      // Add a chain ID if not explicitly set to 0\n      if (auth.chainId == null) {\n        auth.chainId = (yield checkProvider(_this4, \"getNetwork\").getNetwork()).chainId;\n      }\n      // @TODO: Take chain ID into account when populating noce?\n      if (auth.nonce == null) {\n        auth.nonce = yield _this4.getNonce();\n      }\n      return auth;\n    })();\n  }\n  estimateGas(tx) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return checkProvider(_this5, \"estimateGas\").estimateGas(yield _this5.populateCall(tx));\n    })();\n  }\n  call(tx) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return checkProvider(_this6, \"call\").call(yield _this6.populateCall(tx));\n    })();\n  }\n  resolveName(name) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const provider = checkProvider(_this7, \"resolveName\");\n      return yield provider.resolveName(name);\n    })();\n  }\n  sendTransaction(tx) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const provider = checkProvider(_this8, \"sendTransaction\");\n      const pop = yield _this8.populateTransaction(tx);\n      delete pop.from;\n      const txObj = Transaction.from(pop);\n      return yield provider.broadcastTransaction(yield _this8.signTransaction(txObj));\n    })();\n  }\n  // @TODO: in v7 move this to be abstract\n  authorize(authorization) {\n    assert(false, \"authorization not implemented for this signer\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"authorize\"\n    });\n  }\n}\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */\nexport class VoidSigner extends AbstractSigner {\n  /**\n   *  The signer address.\n   */\n  address;\n  /**\n   *  Creates a new **VoidSigner** with %%address%% attached to\n   *  %%provider%%.\n   */\n  constructor(address, provider) {\n    super(provider);\n    defineProperties(this, {\n      address\n    });\n  }\n  getAddress() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return _this9.address;\n    })();\n  }\n  connect(provider) {\n    return new VoidSigner(this.address, provider);\n  }\n  #throwUnsupported(suffix, operation) {\n    assert(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n      operation\n    });\n  }\n  signTransaction(tx) {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      _this0.#throwUnsupported(\"transactions\", \"signTransaction\");\n    })();\n  }\n  signMessage(message) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      _this1.#throwUnsupported(\"messages\", \"signMessage\");\n    })();\n  }\n  signTypedData(domain, types, value) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      _this10.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    })();\n  }\n}\n//# sourceMappingURL=abstract-signer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}