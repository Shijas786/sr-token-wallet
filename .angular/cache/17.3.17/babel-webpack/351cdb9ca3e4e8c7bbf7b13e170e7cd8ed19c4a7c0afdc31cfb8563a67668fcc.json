{"ast":null,"code":"import _asyncToGenerator from \"/Users/shijas/works/sr-token-wallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { defineProperties } from \"../utils/index.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */\nexport class NonceManager extends AbstractSigner {\n  /**\n   *  The Signer being managed.\n   */\n  signer;\n  #noncePromise;\n  #delta;\n  /**\n   *  Creates a new **NonceManager** to manage %%signer%%.\n   */\n  constructor(signer) {\n    super(signer.provider);\n    defineProperties(this, {\n      signer\n    });\n    this.#noncePromise = null;\n    this.#delta = 0;\n  }\n  getAddress() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.signer.getAddress();\n    })();\n  }\n  connect(provider) {\n    return new NonceManager(this.signer.connect(provider));\n  }\n  getNonce(blockTag) {\n    var _superprop_getGetNonce = () => super.getNonce,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (blockTag === \"pending\") {\n        if (_this2.#noncePromise == null) {\n          _this2.#noncePromise = _superprop_getGetNonce().call(_this2, \"pending\");\n        }\n        const delta = _this2.#delta;\n        return (yield _this2.#noncePromise) + delta;\n      }\n      return _superprop_getGetNonce().call(_this2, blockTag);\n    })();\n  }\n  /**\n   *  Manually increment the nonce. This may be useful when managng\n   *  offline transactions.\n   */\n  increment() {\n    this.#delta++;\n  }\n  /**\n   *  Resets the nonce, causing the **NonceManager** to reload the current\n   *  nonce from the blockchain on the next transaction.\n   */\n  reset() {\n    this.#delta = 0;\n    this.#noncePromise = null;\n  }\n  sendTransaction(tx) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const noncePromise = _this3.getNonce(\"pending\");\n      _this3.increment();\n      tx = yield _this3.signer.populateTransaction(tx);\n      tx.nonce = yield noncePromise;\n      // @TODO: Maybe handle interesting/recoverable errors?\n      // Like don't increment if the tx was certainly not sent\n      return yield _this3.signer.sendTransaction(tx);\n    })();\n  }\n  signTransaction(tx) {\n    return this.signer.signTransaction(tx);\n  }\n  signMessage(message) {\n    return this.signer.signMessage(message);\n  }\n  signTypedData(domain, types, value) {\n    return this.signer.signTypedData(domain, types, value);\n  }\n}\n//# sourceMappingURL=signer-noncemanager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}