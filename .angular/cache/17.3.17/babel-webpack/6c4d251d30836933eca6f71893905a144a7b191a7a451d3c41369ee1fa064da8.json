{"ast":null,"code":"import _asyncToGenerator from \"/Users/shijas/works/sr-token-wallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ethers } from 'ethers';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let Web3Service = /*#__PURE__*/(() => {\n  class Web3Service {\n    constructor() {\n      this.provider = null;\n      this.signer = null;\n      this.walletState = new BehaviorSubject({\n        isConnected: false,\n        address: null,\n        balance: '0',\n        networkId: null\n      });\n      // SR Token Contract Address (placeholder - replace with actual deployed contract)\n      this.TOKEN_CONTRACT_ADDRESS = '0x1234567890123456789012345678901234567890';\n      // ERC-20 ABI for token interactions\n      this.ERC20_ABI = ['function name() view returns (string)', 'function symbol() view returns (string)', 'function decimals() view returns (uint8)', 'function totalSupply() view returns (uint256)', 'function balanceOf(address) view returns (uint256)', 'function transfer(address to, uint256 amount) returns (bool)', 'function approve(address spender, uint256 amount) returns (bool)', 'function allowance(address owner, address spender) view returns (uint256)', 'event Transfer(address indexed from, address indexed to, uint256 value)', 'event Approval(address indexed owner, address indexed spender, uint256 value)'];\n      this.initializeProvider();\n    }\n    initializeProvider() {\n      if (typeof window !== 'undefined' && window.ethereum) {\n        this.provider = new ethers.BrowserProvider(window.ethereum);\n        this.setupEventListeners();\n      }\n    }\n    setupEventListeners() {\n      if (typeof window !== 'undefined' && window.ethereum) {\n        window.ethereum.on('accountsChanged', accounts => {\n          if (accounts.length === 0) {\n            this.disconnectWallet();\n          } else {\n            this.getTokenBalance();\n          }\n        });\n        window.ethereum.on('chainChanged', () => {\n          window.location.reload();\n        });\n      }\n    }\n    connectWallet() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this.provider) {\n            throw new Error('MetaMask not detected. Please install MetaMask.');\n          }\n          // Request account access\n          yield _this.provider.send('eth_requestAccounts', []);\n          _this.signer = yield _this.provider.getSigner();\n          const address = yield _this.signer.getAddress();\n          // Get network information\n          const network = yield _this.provider.getNetwork();\n          _this.walletState.next({\n            isConnected: true,\n            address: address,\n            balance: '0',\n            // Will be updated by getTokenBalance\n            networkId: Number(network.chainId)\n          });\n          // Get initial token balance\n          yield _this.getTokenBalance();\n          return true;\n        } catch (error) {\n          console.error('Error connecting wallet:', error);\n          throw error;\n        }\n      })();\n    }\n    disconnectWallet() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.signer = null;\n        _this2.walletState.next({\n          isConnected: false,\n          address: null,\n          balance: '0',\n          networkId: null\n        });\n      })();\n    }\n    getTokenBalance() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this3.signer || !_this3.walletState.value.isConnected) {\n            return '0';\n          }\n          const tokenContract = new ethers.Contract(_this3.TOKEN_CONTRACT_ADDRESS, _this3.ERC20_ABI, _this3.signer);\n          const balance = yield tokenContract['balanceOf'](_this3.walletState.value.address);\n          const formattedBalance = ethers.formatUnits(balance, 18);\n          _this3.walletState.next({\n            ..._this3.walletState.value,\n            balance: formattedBalance\n          });\n          return formattedBalance;\n        } catch (error) {\n          console.error('Error getting token balance:', error);\n          return '0';\n        }\n      })();\n    }\n    getTokenInfo() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this4.signer) {\n            throw new Error('Wallet not connected');\n          }\n          const tokenContract = new ethers.Contract(_this4.TOKEN_CONTRACT_ADDRESS, _this4.ERC20_ABI, _this4.signer);\n          const [name, symbol, decimals, totalSupply, balance] = yield Promise.all([tokenContract['name'](), tokenContract['symbol'](), tokenContract['decimals'](), tokenContract['totalSupply'](), tokenContract['balanceOf'](_this4.walletState.value.address)]);\n          return {\n            symbol,\n            name,\n            decimals,\n            totalSupply: ethers.formatUnits(totalSupply, decimals),\n            balance: ethers.formatUnits(balance, decimals)\n          };\n        } catch (error) {\n          console.error('Error getting token info:', error);\n          throw error;\n        }\n      })();\n    }\n    transferTokens(toAddress, amount) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this5.signer || !_this5.walletState.value.isConnected) {\n            throw new Error('Wallet not connected');\n          }\n          // Validate address\n          if (!ethers.isAddress(toAddress)) {\n            throw new Error('Invalid recipient address');\n          }\n          const tokenContract = new ethers.Contract(_this5.TOKEN_CONTRACT_ADDRESS, _this5.ERC20_ABI, _this5.signer);\n          // Convert amount to wei (assuming 18 decimals)\n          const amountInWei = ethers.parseUnits(amount, 18);\n          // Send transaction\n          const tx = yield tokenContract['transfer'](toAddress, amountInWei);\n          // Wait for transaction confirmation\n          const receipt = yield tx.wait();\n          // Update balance after successful transfer\n          yield _this5.getTokenBalance();\n          return receipt.hash;\n        } catch (error) {\n          console.error('Error transferring tokens:', error);\n          throw error;\n        }\n      })();\n    }\n    getTransactionHistory(address) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this6.provider) {\n            throw new Error('Provider not initialized');\n          }\n          // This would typically use Etherscan API or similar\n          // For now, we'll return an empty array\n          // In a real implementation, you'd fetch from Etherscan API\n          return [];\n        } catch (error) {\n          console.error('Error getting transaction history:', error);\n          return [];\n        }\n      })();\n    }\n    getWalletState() {\n      return this.walletState.asObservable();\n    }\n    getCurrentWalletState() {\n      return this.walletState.value;\n    }\n    isMetaMaskInstalled() {\n      return typeof window !== 'undefined' && !!window.ethereum;\n    }\n    switchNetwork(chainId) {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          if (!_this7.provider) {\n            throw new Error('Provider not initialized');\n          }\n          yield window.ethereum.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{\n              chainId\n            }]\n          });\n        } catch (error) {\n          console.error('Error switching network:', error);\n          throw error;\n        }\n      })();\n    }\n    formatAddress(address) {\n      if (!address) return '';\n      return `${address.slice(0, 6)}...${address.slice(-4)}`;\n    }\n    getEtherscanUrl(txHash) {\n      const networkId = this.walletState.value.networkId;\n      if (networkId === 1) {\n        return `https://etherscan.io/tx/${txHash}`;\n      } else if (networkId === 11155111) {\n        return `https://sepolia.etherscan.io/tx/${txHash}`;\n      } else if (networkId === 5) {\n        return `https://goerli.etherscan.io/tx/${txHash}`;\n      }\n      return `https://etherscan.io/tx/${txHash}`;\n    }\n    static {\n      this.ɵfac = function Web3Service_Factory(t) {\n        return new (t || Web3Service)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: Web3Service,\n        factory: Web3Service.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return Web3Service;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}