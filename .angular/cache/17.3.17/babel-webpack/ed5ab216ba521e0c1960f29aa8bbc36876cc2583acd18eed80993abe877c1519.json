{"ast":null,"code":"import _asyncToGenerator from \"/Users/shijas/works/sr-token-wallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { scrypt as _nobleSync, scryptAsync as _nobleAsync } from \"@noble/hashes/scrypt\";\nimport { getBytes, hexlify as H } from \"../utils/index.js\";\nlet lockedSync = false,\n  lockedAsync = false;\nconst _scryptAsync = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (passwd, salt, N, r, p, dkLen, onProgress) {\n    return yield _nobleAsync(passwd, salt, {\n      N,\n      r,\n      p,\n      dkLen,\n      onProgress\n    });\n  });\n  return function _scryptAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\n  return _nobleSync(passwd, salt, {\n    N,\n    r,\n    p,\n    dkLen\n  });\n};\nlet __scryptAsync = _scryptAsync;\nlet __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scrypt(_x8, _x9, _x0, _x1, _x10, _x11, _x12) {\n  return _scrypt.apply(this, arguments);\n}\nfunction _scrypt() {\n  _scrypt = _asyncToGenerator(function* (_passwd, _salt, N, r, p, dkLen, progress) {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(yield __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n  });\n  return _scrypt.apply(this, arguments);\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function () {\n  lockedAsync = true;\n};\nscrypt.register = function (func) {\n  if (lockedAsync) {\n    throw new Error(\"scrypt is locked\");\n  }\n  __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scryptSync(_passwd, _salt, N, r, p, dkLen) {\n  const passwd = getBytes(_passwd, \"passwd\");\n  const salt = getBytes(_salt, \"salt\");\n  return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function () {\n  lockedSync = true;\n};\nscryptSync.register = function (func) {\n  if (lockedSync) {\n    throw new Error(\"scryptSync is locked\");\n  }\n  __scryptSync = func;\n};\nObject.freeze(scryptSync);\n//# sourceMappingURL=scrypt.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}